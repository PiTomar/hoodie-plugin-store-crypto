declare class CryptoStore {
  constructor(hoodieApi: any, options?: CryptoStore.CryptoStoreOptions);

  /**
   * Setup encryption. Required on sign up or when encryption is started.
   * @param password The users password for encrypting the objects.
   * @param salt Not recommended! To add another protection lair, as a second password.
   *             If this is missing, a salt will be securely generated. Which will result in a
   *             different encryption!
   * @returns 10 ResetKeys. They are used to reset the password.
   */
  setup(
    password: string,
    salt?: CryptoStore.Salt
  ): Promise<CryptoStore.ResetKeys>;

  /**
   * Unlocks the CryptoStore instance. Required be using it.
   * @param password The users password foe encrypting the objects.
   */
  unlock(password: string): Promise<void>;

  /**
   * Changes the encryption password and salt. Then it will update all encrypted documents.
   * All encrypted documents, that couldn't get decrypted, will not get updated!
   * The Array, at the notUpdated field, will include all their _ids.
   * @param oldPassword The old password, that was used up until now.
   * @param nextPassword New password, with which the docs will be encrypted.
   */
  changePassword(
    oldPassword: string,
    nextPassword: string
  ): Promise<CryptoStore.PasswordChangeResult>;

  /**
   * This is for when the user did forget their password.
   * Changes the encryption password and salt. Then it will update all encrypted documents.
   * All encrypted documents, that couldn't get decrypted, will not get updated!
   * The Array, at the notUpdated field, will include all their _ids.
   * @param resetKey One of the resetKeys generated by setup(), changePassword() and resetPassword()
   * @param nextPassword New password, with which the docs will be encrypted.
   */
  resetPassword(
    resetKey: CryptoStore.ResetKey,
    nextPassword: string
  ): Promise<CryptoStore.PasswordChangeResult>;

  /**
   * Locks the store.
   * `unlock` must then get called again.
   */
  lock(): boolean;

  /**
   * Add an array of objects/documents to the store, encrypted.
   * @param properties Objects/documents that should be added encrypted.
   * @returns The decrypted version of the document(s).
   */
  add<T extends CryptoStore.NewObject>(
    properties: T[]
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;
  /**
   * Add an object/document to the store, encrypted.
   * @param properties Objects/documents that should be added encrypted.
   * @returns The decrypted version of the document(s).
   */
  add<T extends CryptoStore.NewObject>(
    properties: T
  ): Promise<T & CryptoStore.HoodieDoc>;

  /**
   * Finds one object/document.
   * @param id Id of the document/object to find.
   */
  find<T extends {}>(id: string): Promise<T & CryptoStore.HoodieDoc>;
  /**
   * Finds multiple documents/objects in one go.
   * @param idsOrDocs Array of IDs or objects with an ID to find.
   */
  find<T extends {}>(
    idsOrDocs: (string | (T & CryptoStore.ObjectWithId))[]
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;
  /**
   * Find an object/document in the store using an existing version of it.
   * @param doc Object with an ID. The ID will be used to find the object.
   */
  find<T extends CryptoStore.ObjectWithId>(
    doc: T
  ): Promise<T & CryptoStore.HoodieDoc>;

  /**
   * Finds a document/object. If none was found, create it.
   * @param id ID of the document/object to find or add.
   * @param doc Body of the document/object to add if no existing doc could be found.
   */
  findOrAdd<T extends {}>(
    id: string,
    doc: T
  ): Promise<T & CryptoStore.HoodieDoc>;
  /**
   * Finds many documents/objects. If one was not found, create it.
   * @param docs Array of objects with _id.
   */
  findOrAdd<T extends {}>(
    docs: (T & CryptoStore.ObjectWithId)[]
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;
  /**
   * Finds a document/object. If none was found, create it.
   * @param doc Object/document with an _id.
   */
  findOrAdd<T extends CryptoStore.ObjectWithId>(
    doc: T
  ): Promise<T & CryptoStore.HoodieDoc>;

  /**
   * Find all documents/objects.
   * @param filterFunction Optional filter function. Works like Array::filter.
   */
  findAll<T extends {}>(
    filterFunction?: CryptoStore.FilterFunction<T>
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;

  /**
   * Update a document/object.
   * @param id ID of the object/document to update.
   * @param changedProperties Properties/fields that should be updated.
   * @returns The updated decrypted version.
   */
  update<T extends M, M extends {} = T>(
    id: string,
    changedProperties: M
  ): Promise<T & CryptoStore.HoodieDoc>;
  /**
   * Update a document/object with an update function.
   * @param id ID of the object/document to update.
   * @param updateFunction Function that updates an object using side-effects.
   * @returns The updated decrypted version.
   */
  update<T extends {}>(
    id: string,
    updateFunction: (doc: T & CryptoStore.HoodieDoc) => void
  ): Promise<T & CryptoStore.HoodieDoc>;
  /**
   * Updates multiple documents/objects with provided diffs.
   * @param arrayOfDocs Array of Objects with _id and their changed fields.
   * @returns The updated decrypted versions.
   */
  update<T extends M, M extends CryptoStore.ObjectWithId = T>(
    arrayOfDocs: M[]
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;
  /**
   * Updates an object/document with a provided diff.
   * @param doc Object with an _id and the updated fields.
   * @returns The updated decrypted version.
   */
  update<T extends M, M extends CryptoStore.ObjectWithId = T>(
    doc: M
  ): Promise<T & CryptoStore.HoodieDoc>;

  /**
   * Updates an existing object/document or creates a new one.
   * @param id ID of the object/document to update.
   * @param doc Body of the new object or the changed fields.
   */
  updateOrAdd<T>(id: string, doc: T): Promise<T & CryptoStore.HoodieDoc>;
  /**
   * Updates or creates multiple documents/objects.
   * @param arrayOfDocs Array of objects with _id and their default values.
   */
  updateOrAdd<T extends CryptoStore.ObjectWithId>(
    arrayOfDocs: T[]
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;
  /**
   * Updates an existing object/document or creates a new one.
   * @param doc Object with an _id field and its default/changed fields values.
   */
  updateOrAdd<T extends CryptoStore.ObjectWithId>(
    doc: T
  ): Promise<T & CryptoStore.HoodieDoc>;

  /**
   * Updates all documents.
   * @param changedProperties Fields/properties that should be updated on all documents.
   */
  updateAll<T extends M, M extends {} = T>(
    changedProperties: M
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;
  /**
   * Updates all documents.
   * @param updateFunction Function that updates every object in place (side effect).
   */
  updateAll<T extends {}>(
    updateFunction: (
      doc: T & CryptoStore.HoodieDoc,
      index: number,
      array: (T & CryptoStore.HoodieDoc)[]
    ) => void
  ): Promise<(T & CryptoStore.HoodieDoc)[]>;

  /**
   * Remove/deletes a document/object.
   * @param id Id of the document/object that should be removed.
   */
  remove<T extends {}>(id: string): Promise<T & CryptoStore.DeletedHoodieDoc>;
  /**
   * Deletes and optional updates multiple documents.
   * @param idsOrDocs Array of ID or object with _id (and their changed fields).
   */
  remove<T extends M, M extends CryptoStore.ObjectWithId = T>(
    idsOrDocs: (string | M)[]
  ): Promise<(T & CryptoStore.DeletedHoodieDoc)[]>;
  /**
   * Remove/deletes a document/object while updating some fields on it.
   * @param doc Object with _id and fields that should be updated.
   */
  remove<T extends M, M extends CryptoStore.ObjectWithId = T>(
    doc: M
  ): Promise<T & CryptoStore.DeletedHoodieDoc>;

  /**
   * Remote all documents.
   * @param filterFunction Optional filter function. Like Array::filter.
   *                       true = Object will get removed.
   */
  removeAll<T extends {}>(
    filterFunction?: CryptoStore.FilterFunction<T>
  ): Promise<(T & CryptoStore.DeletedHoodieDoc)[]>;

  /**
   * Checks if an Objects could be an encrypted object.
   * @param promise Promise that resolves into an Object.
   */
  isEncrypted(promise: Promise<unknown>): Promise<boolean>;
  /**
   * Checks if an Objects could be an encrypted object.
   * @param object Object to check.
   */
  isEncrypted(object: unknown): boolean;

  /**
   * Encrypt any JSON-data without storing them. Uses the same encryption key as any other method.
   * @param object Data that should be encrypted.
   *               This can be anything that can also be passed to JSON.stringify()
   * @param aad    Optional additional validation. If present, then it must also be present and
   *               the same value/content when decrypting.
   */
  encrypt(
    object: unknown,
    aad?: string | Buffer | Uint8Array
  ): Promise<CryptoStore.EncryptedObject>;

  /**
   * Decrypt everything encrypted with cryptoStore.encrypt() or any other methods.
   * Uses the same encryption key as any other method.
   *
   * To decrypt an object stored with an other method, use its _id as the aad!
   * `cryptoStore.decrypt(obj, obj._id)`.
   * @param encrypted Data that is encrypted.
   *                  All fields on the object other than data, tag and nonce will be ignored.
   * @param aad Optional additional validation. Required if it was present when encrypting.
   *            _id for all objects encrypted by other methods.
   */
  decrypt<T>(
    encrypted: CryptoStore.EncryptedObject,
    aad?: string | Buffer | Uint8Array
  ): Promise<T>;

  /**
   * Add an `add` event-handler. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "add",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Add an `update` event-handler. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "update",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Add an `remove` event-handler. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "remove",
    handler: (doc: T & CryptoStore.DeletedHoodieDoc) => void
  ): this;
  /**
   * Add an event-handler for all changes. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "change",
    handler: (
      eventName: "add" | "update" | "remove",
      doc: T & CryptoStore.HoodieDoc
    ) => void
  ): this;
  /**
   * Add an `add` event-handler. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "add",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Add an `update` event-handler. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "update",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Add an `remove` event-handler. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "remove",
    handler: (doc: T & CryptoStore.DeletedHoodieDoc) => void
  ): this;
  /**
   * Add an event-handler for all changes. Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  on<T extends {}>(
    eventName: "change",
    handler: (
      eventName: "add" | "update" | "remove",
      doc: T & CryptoStore.HoodieDoc
    ) => void
  ): this;

  /**
   * Remove the provided `add` event-handler.
   * @param eventName Name of the subscribed event.
   * @param handler Event Handler function.
   */
  off<T extends {}>(
    eventName: "add",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Remove the provided `update` event-handler.
   * @param eventName Name of the subscribed event.
   * @param handler Event Handler function.
   */
  off<T extends {}>(
    eventName: "update",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Remove the provided `remove` event-handler.
   * @param eventName Name of the subscribed event.
   * @param handler Event Handler function.
   */
  off<T extends {}>(
    eventName: "remove",
    handler: (doc: T & CryptoStore.DeletedHoodieDoc) => void
  ): this;
  /**
   * Remove the provided `change` event-handler.
   * @param eventName Name of the subscribed event.
   * @param handler Event Handler function.
   */
  off<T extends {}>(
    eventName: "change",
    handler: (
      eventName: "add" | "update" | "remove",
      doc: T & CryptoStore.HoodieDoc
    ) => void
  ): this;

  /**
   * Add a one time `add` event-handler.
   * After the first event was emitted, the handler will unsubscribe.
   * Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  one<T extends {}>(
    eventName: "add",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Add a one time `update` event-handler.
   * After the first event was emitted, the handler will unsubscribe.
   * Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  one<T extends {}>(
    eventName: "update",
    handler: (doc: T & CryptoStore.HoodieDoc) => void
  ): this;
  /**
   * Add a one time `remove` event-handler.
   * After the first event was emitted, the handler will unsubscribe.
   * Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  one<T extends {}>(
    eventName: "remove",
    handler: (doc: T & CryptoStore.DeletedHoodieDoc) => void
  ): this;
  /**
   * Add a one time event-handler for all events.
   * After the first event was emitted, the handler will unsubscribe.
   * Events are only emitted for encrypted object/documents.
   * Use Hoodies events or PouchDBs change events for all objects/documents.
   * @param eventName Name of the event to listen to.
   * @param handler Event Handler function.
   */
  one<T extends {}>(
    eventName: "change",
    handler: (
      eventName: "add" | "update" | "remove",
      doc: T & CryptoStore.HoodieDoc
    ) => void
  ): this;

  /**
   * Get a subset of the CryptoStore API that works on objects/documents with the provided prefix.
   *
   * Add doc added will have the prefix. Find, update and remove only finds docs with that prefix.
   * findAll, updateAll and removeAll are also limited to documents with this prefix.
   * Events are only emitted for documents/objects with this prefix.
   *
   * withIdPrefix of the resulting API will add its prefix to this prefix:
   * ```javascript
   * // _id will be 'test:moar:a'
   * store.withIdPrefix('test:').withIdPrefix('moar:').add({ _id: 'a' })
   * ```
   * @param prefix Prefix that will be added to all _id's.
   */
  withIdPrefix<T extends {} = {}>(
    prefix: string
  ): CryptoStore.CryptoStoreApi<T>;

  /**
   * Create a subset of the CryptoStore-API with an other password.
   * All methods will use the provided password. Event only emitted for objects/documents
   * which are encrypted with the provided password.
   *
   * It is recommended to not pass a salt at the _first_ use.
   * But store it! And use the stored _salt_ in subsequent uses.
   * Both _password_ **and** _salt_ must match to work!
   *
   * This can also be used when the main CryptoStore instance is not unlocked!
   * @param password Password used in this sub API.
   * @param salt Salt used in this sub API. A secure salt is generated is non gets passed.
   */
  withPassword<T extends {} = {}>(
    password: string,
    salt?: string
  ): Promise<{
    store: CryptoStore.CryptoStoreApiWithEncrypt<T>;
    salt: string;
  }>;
}

declare namespace CryptoStore {
  export interface CryptoStoreOptions {
    noPasswordCheckAutoFix?: boolean;
    remote?: any;
  }

  export interface NewObject {
    _id?: string;
  }

  export interface ObjectWithId {
    _id: string;
  }

  export interface HoodieDoc {
    _id: string;
    _rev: string;
    _deleted?: boolean;
    hoodie: {
      createdAt: string;
      updatedAt?: string;
      deletedAt?: string;
    };
  }

  export interface DeletedHoodieDoc extends HoodieDoc {
    _deleted: true;
    hoodie: {
      createdAt: string;
      updatedAt: string;
      deletedAt: string;
    };
  }

  export interface EncryptedObject {
    nonce: string;
    tag: string;
    data: string;
  }

  export type IdOrDocs<T> = string | (T & ObjectWithId);

  /** A Key used to reset a forgotten password. */
  export type ResetKey = string;
  /** 10 ResetKeys */
  export type ResetKeys = ResetKey[];
  /** A 32 Char long hash. */
  export type Salt = string;

  export type FilterFunction<T> = (
    doc: T & HoodieDoc,
    index: number,
    array: (T & HoodieDoc)[]
  ) => boolean;

  export interface PasswordChangeResult {
    /** New Salt */
    salt: Salt;
    /** IDs of Documents that couldn't get updated. They are encrypted with a different key. */
    notUpdated: string[];
    /** New resetKeys. */
    resetKeys: ResetKeys;
  }

  export interface CryptoStoreApi<BaseType> {
    add<T extends BaseType>(properties: T): Promise<T & HoodieDoc>;

    withIdPrefix<T extends {} = BaseType>(prefix: string): CryptoStoreApi<T>;
  }

  export interface CryptoStoreApiWithEncrypt<BaseType>
    extends CryptoStoreApi<BaseType> {
    /**
     * Checks if an Objects could be an encrypted object.
     * @param promise Promise that resolves into an Object.
     */
    isEncrypted(promise: Promise<unknown>): Promise<boolean>;
    /**
     * Checks if an Objects could be an encrypted object.
     * @param object Object to check.
     */
    isEncrypted(object: unknown): boolean;

    /**
     * Encrypt any JSON-data without storing them. Uses the same encryption key as any other method.
     * @param object Data that should be encrypted.
     *               This can be anything that can also be passed to JSON.stringify()
     * @param aad    Optional additional validation. If present, then it must also be present and
     *               the same value/content when decrypting.
     */
    encrypt(
      object: unknown,
      aad?: string | Buffer | Uint8Array
    ): Promise<CryptoStore.EncryptedObject>;

    /**
     * Decrypt everything encrypted with cryptoStore.encrypt() or any other methods.
     * Uses the same encryption key as any other method.
     *
     * To decrypt an object stored with an other method, use its _id as the aad!
     * `cryptoStore.decrypt(obj, obj._id)`.
     * @param encrypted Data that is encrypted.
     *                  All fields on the object other than data, tag and nonce will be ignored.
     * @param aad Optional additional validation. Required if it was present when encrypting.
     *            _id for all objects encrypted by other methods.
     */
    decrypt<T>(
      encrypted: CryptoStore.EncryptedObject,
      aad?: string | Buffer | Uint8Array
    ): Promise<T>;
  }
}

export = CryptoStore;
